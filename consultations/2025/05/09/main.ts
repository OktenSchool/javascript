// "Есть ли смысл создавать какой-то тип или интерфейс для пропсов класса (типа, если нужно использовать модификаторы доступа,
// то получается, придётся сверху инициализировать свойства, и получится кучка лишнего кода)?

// import ExperienceType from ExperienceType.ts;

type ExperienceType = {
    title: string;
    exp: number
}

class User {

    constructor(private id: number, private name: string, private epx: ExperienceType) {
    }
}

// Я так понимаю, что когда мы инициализируем свойства в конструкторе класса и даём модификаторы, то можно обойтись без лишнего кода, типа this.radius = radius в конструкторе.
//

//     Если поле инициализировать, например, сделать его #radius, то доступ, как я заметил, и в ts, и в js будет ограничен, верно?
//     И насколько часто используется такая практика?
//
//     Я правильно понимаю, что если, например, делать имплементацию для класса и наследоваться от абстрактного класса, то разница лишь в том,
//     что в интерфейсах или типах мы просто задаём правила, а в абстрактном классе мы можем ещё добавить условную логику, например?

// interface AI {
//     ai: () => void;
// }
//
// interface BI {
//     bi: () => void;
// }
//
// class A implements AI, BI {
//     ai(): void {
//     }
//
//     bi(): void {
//     }
//
// }
//
// abstract class B {
//     foo: () => void
// }
//
// class C extends B {
//     foo: () => {
//         //.....
//     }
// }


class A {
    //....a
}

class B extends A {
    //....a
    //....b
}

const a: A = new B(); // a



//     И ещё вопрос: почему, когда мы говорим class A extends class B, мы говорим, что класс A расширяет класс B? Ведь логичнее было бы сказать,
//     что класс A расширяется от класса B (просто интересно с точки зрения семантики)?"
